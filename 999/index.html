<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大老二 - 玩家 vs 3 AI</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #table {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 400px;
            height: 200px;
            background-color: #4CAF50;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #table-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            align-items: center;
        }
        .card {
            width: 50px;
            height: 70px;
            background-color: white;
            border: 1px solid #333;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            cursor: pointer;
        }
        .card.selected {
            border: 2px solid #ff0;
            transform: translateY(-10px);
        }
        #player-hand {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            max-width: 600px;
        }
        #opponents {
            display: flex;
            justify-content: space-between;
            width: 600px;
        }
        .opponent {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .opponent-hand {
            display: flex;
            gap: 5px;
        }
        .opponent-card {
            width: 30px;
            height: 40px;
            background-color: #ccc;
            border: 1px solid #333;
            border-radius: 5px;
        }
        #controls {
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        #status {
            font-size: 18px;
            color: #333;
        }
        #scores {
            font-size: 16px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="opponents">
            <div class="opponent">
                <div>AI 1</div>
                <div class="opponent-hand" id="ai1-hand"></div>
            </div>
            <div class="opponent">
                <div>AI 2</div>
                <div class="opponent-hand" id="ai2-hand"></div>
            </div>
            <div class="opponent">
                <div>AI 3</div>
                <div class="opponent-hand" id="ai3-hand"></div>
            </div>
        </div>
        <div id="table">
            <div id="table-cards"></div>
        </div>
        <div id="status">等待開始...</div>
        <div id="scores">得分: 玩家: 0 | AI 1: 0 | AI 2: 0 | AI 3: 0</div>
        <div id="controls">
            <button onclick="playCards()">出牌</button>
            <button onclick="pass()">過牌</button>
            <button onclick="resetGame()">重置遊戲</button>
        </div>
        <div id="player-hand"></div>
    </div>

    <script>
        // 卡牌定義
        const suits = ['♠', '♥', '♣', '♦'];
        const ranks = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
        const suitOrder = { '♠': 4, '♥': 3, '♣': 2, '♦': 1 };
        const rankOrder = { '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, '10': 8, 'J': 9, 'Q': 10, 'K': 11, 'A': 12, '2': 13 };

        // 遊戲狀態
        let deck = [];
        let hands = [[], [], [], []]; // 玩家, AI1, AI2, AI3
        let tableCards = [];
        let currentPlayer = 0;
        let lastPlayed = null;
        let scores = [0, 0, 0, 0];
        let selectedCards = [];
        let passes = 0;

        // 初始化遊戲
        function initGame() {
            deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            deck.sort(() => Math.random() - 0.5);
            hands = [[], [], [], []];
            for (let i = 0; i < 52; i++) {
                hands[i % 4].push(deck[i]);
            }
            hands.forEach(hand => hand.sort(compareCards));
            currentPlayer = hands.findIndex(hand => hand.some(card => card.rank === '3' && card.suit === '♦'));
            tableCards = [];
            lastPlayed = null;
            selectedCards = [];
            passes = 0;
            updateUI();
            updateStatus();
        }

        // 比較卡牌大小
        function compareCards(a, b) {
            if (rankOrder[a.rank] !== rankOrder[b.rank]) {
                return rankOrder[b.rank] - rankOrder[a.rank];
            }
            return suitOrder[b.suit] - suitOrder[a.suit];
        }

        // 更新界面
        function updateUI() {
            // 玩家手牌
            const playerHand = document.getElementById('player-hand');
            playerHand.innerHTML = '';
            hands[0].forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card');
                if (selectedCards.includes(index)) {
                    cardDiv.classList.add('selected');
                }
                cardDiv.textContent = `${card.suit}${card.rank}`;
                cardDiv.onclick = () => toggleCardSelection(index);
                playerHand.appendChild(cardDiv);
            });

            // AI手牌
            for (let i = 1; i <= 3; i++) {
                const aiHand = document.getElementById(`ai${i}-hand`);
                aiHand.innerHTML = '';
                for (let j = 0; j < hands[i].length; j++) {
                    const cardDiv = document.createElement('div');
                    cardDiv.classList.add('opponent-card');
                    aiHand.appendChild(cardDiv);
                }
            }

            // 桌面卡牌
            const tableDiv = document.getElementById('table-cards');
            tableDiv.innerHTML = '';
            tableCards.forEach(card => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card');
                cardDiv.textContent = `${card.suit}${card.rank}`;
                tableDiv.appendChild(cardDiv);
            });

            // 分數
            document.getElementById('scores').textContent = `得分: 玩家: ${scores[0]} | AI 1: ${scores[1]} | AI 2: ${scores[2]} | AI 3: ${scores[3]}`;
        }

        // 更新狀態
        function updateStatus() {
            const names = ['玩家', 'AI 1', 'AI 2', 'AI 3'];
            if (hands.some(hand => hand.length === 0)) {
                calculateScores();
                document.getElementById('status').textContent = `回合結束！${names[hands.findIndex(hand => hand.length === 0)]} 獲勝！`;
            } else {
                document.getElementById('status').textContent = `輪到 ${names[currentPlayer]}`;
            }
        }

        // 選擇卡牌
        function toggleCardSelection(index) {
            if (currentPlayer !== 0) return;
            const idx = selectedCards.indexOf(index);
            if (idx === -1) {
                selectedCards.push(index);
            } else {
                selectedCards.splice(idx, 1);
            }
            updateUI();
        }

        // 出牌
        function playCards() {
            if (currentPlayer !== 0) return;
            const cards = selectedCards.map(i => hands[0][i]);
            if (cards.length === 0) {
                alert('請選擇卡牌！');
                return;
            }
            const combo = getCombination(cards);
            if (!combo) {
                alert('無效組合！');
                selectedCards = [];
                updateUI();
                return;
            }
            if (lastPlayed && !canBeat(combo, lastPlayed)) {
                alert('出牌必須大於桌面上的牌！');
                selectedCards = [];
                updateUI();
                return;
            }
            if (lastPlayed && combo.type !== lastPlayed.type) {
                alert('組合類型必須相同！');
                selectedCards = [];
                updateUI();
                return;
            }
            if (!lastPlayed && cards.length > 0 && !cards.some(card => card.rank === '3' && card.suit === '♦')) {
                alert('第一輪必須包含♦3！');
                selectedCards = [];
                updateUI();
                return;
            }
            tableCards = cards;
            lastPlayed = combo;
            selectedCards.sort((a, b) => b - a);
            for (let i of selectedCards) {
                hands[0].splice(i, 1);
            }
            selectedCards = [];
            passes = 0;
            nextPlayer();
        }

        // 過牌
        function pass() {
            if (currentPlayer !== 0) return;
            passes++;
            if (passes >= 3) {
                tableCards = [];
                lastPlayed = null;
                passes = 0;
            }
            nextPlayer();
        }

        // 下一個玩家
        function nextPlayer() {
            currentPlayer = (currentPlayer + 1) % 4;
            updateUI();
            updateStatus();
            if (hands[currentPlayer].length === 0) {
                calculateScores();
                return;
            }
            if (currentPlayer !== 0) {
                setTimeout(aiPlay, 1000);
            }
        }

        // AI出牌
        function aiPlay() {
            const hand = hands[currentPlayer];
            if (!lastPlayed) {
                // 包含♦3的出牌
                let cards = hand.filter(card => card.rank === '3' && card.suit === '♦');
                if (cards.length > 0) {
                    tableCards = cards;
                    lastPlayed = getCombination(cards);
                    hands[currentPlayer] = hand.filter(card => !cards.includes(card));
                    passes = 0;
                    nextPlayer();
                    return;
                }
            }
            // 簡單策略：嘗試出最小的合法組合
            const combos = getAllCombinations(hand);
            let validCombo = null;
            for (let combo of combos) {
                if (!lastPlayed || (combo.type === lastPlayed.type && canBeat(combo, lastPlayed))) {
                    validCombo = combo;
                    break;
                }
            }
            if (validCombo) {
                tableCards = validCombo.cards;
                lastPlayed = validCombo;
                hands[currentPlayer] = hand.filter(card => !validCombo.cards.includes(card));
                passes = 0;
            } else {
                passes++;
                if (passes >= 3) {
                    tableCards = [];
                    lastPlayed = null;
                    passes = 0;
                }
            }
            nextPlayer();
        }

        // 獲取卡牌組合
        function getCombination(cards) {
            cards.sort(compareCards);
            if (cards.length === 1) {
                return { type: 'single', value: rankOrder[cards[0].rank], suit: suitOrder[cards[0].suit], cards };
            }
            if (cards.length === 2 && cards[0].rank === cards[1].rank) {
                return { type: 'pair', value: rankOrder[cards[0].rank], suit: Math.max(suitOrder[cards[0].suit], suitOrder[cards[1].suit]), cards };
            }
            if (cards.length === 3 && cards[0].rank === cards[1].rank && cards[1].rank === cards[2].rank) {
                return { type: 'triple', value: rankOrder[cards[0].rank], cards };
            }
            if (cards.length === 5) {
                if (isStraightFlush(cards)) return { type: 'straightFlush', value: rankOrder[cards[0].rank], cards };
                if (isFourOfAKind(cards)) return { type: 'fourOfAKind', value: rankOrder[cards[1].rank], cards };
                if (isFullHouse(cards)) return { type: 'fullHouse', value: rankOrder[cards[2].rank], cards };
                if (isFlush(cards)) return { type: 'flush', value: rankOrder[cards[0].rank], suit: suitOrder[cards[0].suit], cards };
                if (isStraight(cards)) return { type: 'straight', value: rankOrder[cards[0].rank], cards };
            }
            return null;
        }

        // 檢查是否能打敗
        function canBeat(newCombo, oldCombo) {
            if (newCombo.type !== oldCombo.type) return false;
            if (['single', 'pair', 'flush'].includes(newCombo.type)) {
                if (newCombo.value !== oldCombo.value) {
                    return newCombo.value > oldCombo.value;
                }
                return newCombo.suit > oldCombo.suit;
            }
            if (['straightFlush', 'fourOfAKind', 'fullHouse', 'straight', 'triple'].includes(newCombo.type)) {
                return newCombo.value > oldCombo.value;
            }
            return false;
        }

        // 獲取所有可能組合
        function getAllCombinations(hand) {
            let combos = [];
            // 單張
            hand.forEach(card => combos.push({ type: 'single', value: rankOrder[card.rank], suit: suitOrder[card.suit], cards: [card] }));
            // 對子
            for (let i = 0; i < hand.length - 1; i++) {
                if (hand[i].rank === hand[i + 1].rank) {
                    combos.push({ type: 'pair', value: rankOrder[hand[i].rank], suit: Math.max(suitOrder[hand[i].suit], suitOrder[hand[i + 1].suit]), cards: [hand[i], hand[i + 1]] });
                }
            }
            // 三條
            for (let i = 0; i < hand.length - 2; i++) {
                if (hand[i].rank === hand[i + 1].rank && hand[i + 1].rank === hand[i + 2].rank) {
                    combos.push({ type: 'triple', value: rankOrder[hand[i].rank], cards: [hand[i], hand[i + 1], hand[i + 2]] });
                }
            }
            // 五張組合（簡化版）
            if (hand.length >= 5) {
                let fiveCards = hand.slice(0, 5);
                let combo = getCombination(fiveCards);
                if (combo) combos.push(combo);
            }
            return combos.sort((a, b) => {
                if (a.value !== b.value) return a.value - b.value;
                if (a.suit && b.suit) return a.suit - b.suit;
                return 0;
            });
        }

        // 五張牌組合檢查
        function isStraight(cards) {
            let values = cards.map(card => rankOrder[card.rank]).sort((a, b) => b - a);
            for (let i = 1; i < values.length; i++) {
                if (values[i - 1] - values[i] !== 1) return false;
            }
            return true;
        }

        function isFlush(cards) {
            return cards.every(card => card.suit === cards[0].suit);
        }

        function isFullHouse(cards) {
            let ranks = cards.map(card => card.rank);
            let counts = {};
            ranks.forEach(rank => counts[rank] = (counts[rank] || 0) + 1);
            return Object.values(counts).sort().join('') === '23';
        }

        function isFourOfAKind(cards) {
            let ranks = cards.map(card => card.rank);
            let counts = {};
            ranks.forEach(rank => counts[rank] = (counts[rank] || 0) + 1);
            return Object.values(counts).includes(4);
        }

        function isStraightFlush(cards) {
            return isStraight(cards) && isFlush(cards);
        }

        // 計算得分
        function calculateScores() {
            let winner = hands.findIndex(hand => hand.length === 0);
            if (winner === -1) return;
            let points = 0;
            hands.forEach((hand, index) => {
                if (index !== winner) {
                    let count = hand.length;
                    let penalty = count <= 9 ? count : count <= 12 ? count * 2 : count * 3;
                    points += penalty;
                }
            });
            scores[winner] += points;
            updateUI();
            updateStatus();
        }

        // 重置遊戲
        function resetGame() {
            scores = [0, 0, 0, 0];
            initGame();
        }

        // 初始化遊戲
        initGame();
    </script>
</body>
</html>