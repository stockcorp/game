<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大老二 - 玩家 vs 3 AI</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            width: 900px;
            min-height: 600px;
        }
        #table {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 450px;
            height: 225px;
            background-color: #4CAF50;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            position: relative;
        }
        #table-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            align-items: center;
            min-height: 84px;
        }
        .card {
            width: 60px;
            height: 84px;
            background-color: white;
            border: 1px solid #333;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card.red {
            color: red;
        }
        .card.black {
            color: black;
        }
        .card.selected {
            border: 2px solid #ff0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transform: translateY(-15px);
        }
        .card.animate {
            animation: slideToTable 0.5s ease-out forwards;
        }
        @keyframes slideToTable {
            from { transform: translate(0, 0); opacity: 1; }
            to { transform: translate(0, 0); opacity: 1; }
        }
        #player-hand {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            max-width: 720px;
        }
        #opponents {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .opponent {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            font-size: 18px;
        }
        .opponent-hand {
            display: flex;
            gap: 5px;
        }
        .opponent-card {
            width: 36px;
            height: 48px;
            background-color: #ccc;
            border: 1px solid #333;
            border-radius: 5px;
        }
        #ai1 {
            position: absolute;
            top: -140px;
            left: 50%;
            transform: translateX(-50%);
        }
        #ai2 {
            position: absolute;
            right: -120px;
            top: 50%;
            transform: translateY(-50%);
        }
        #ai2 .opponent-hand {
            flex-direction: column;
        }
        #ai3 {
            position: absolute;
            left: -120px;
            top: 50%;
            transform: translateY(-50%);
        }
        #ai3 .opponent-hand {
            flex-direction: column;
        }
        #controls {
            display: flex;
            gap: 10px;
        }
        button {
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        #status {
            font-size: 20px;
            color: #333;
        }
        #scores {
            font-size: 18px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="opponents">
            <div class="opponent" id="ai1">
                <div>AI 1</div>
                <div class="opponent-hand" id="ai1-hand"></div>
            </div>
            <div class="opponent" id="ai2">
                <div>AI 2</div>
                <div class="opponent-hand" id="ai2-hand"></div>
            </div>
            <div class="opponent" id="ai3">
                <div>AI 3</div>
                <div class="opponent-hand" id="ai3-hand"></div>
            </div>
        </div>
        <div id="table">
            <div id="table-cards"></div>
        </div>
        <div id="status">等待開始...</div>
        <div id="scores">得分: 玩家: 0 | AI 1: 0 | AI 2: 0 | AI 3: 0</div>
        <div id="controls">
            <button onclick="playCards()">出牌</button>
            <button onclick="pass()">過牌</button>
            <button onclick="resetGame()">重置遊戲</button>
        </div>
        <div id="player-hand"></div>
    </div>

    <script>
        // 卡牌定義
        const suits = ['♠', '♥', '♣', '♦'];
        const ranks = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
        const suitOrder = { '♠': 4, '♥': 3, '♣': 2, '♦': 1 };
        const rankOrder = { '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, '10': 8, 'J': 9, 'Q': 10, 'K': 11, 'A': 12, '2': 13 };

        // 遊戲狀態
        let deck = [];
        let hands = [[], [], [], []]; // 玩家, AI1, AI2, AI3
        let tableCards = [];
        let currentPlayer = 0;
        let lastPlayed = null;
        let scores = [0, 0, 0, 0];
        let selectedCards = [];
        let passes = 0;

        // 音效
        const startSound = new Audio('start.mp3');
        const passSound = new Audio('pass.mp3');
        const playSound = new Audio('po.mp3');

        // 初始化遊戲
        function initGame() {
            startSound.play().catch(e => console.log('Start sound error:', e));
            deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            deck.sort(() => Math.random() - 0.5);
            hands = [[], [], [], []];
            for (let i = 0; i < 52; i++) {
                hands[i % 4].push(deck[i]);
            }
            hands.forEach(hand => hand.sort(compareCards));
            currentPlayer = hands.findIndex(hand => hand.some(card => card.rank === '3' && card.suit === '♣'));
            if (currentPlayer === -1) currentPlayer = 0; // 防止無♣3的情況
            tableCards = [];
            lastPlayed = null;
            selectedCards = [];
            passes = 0;
            updateUI();
            updateStatus();
        }

        // 比較卡牌大小
        function compareCards(a, b) {
            if (rankOrder[a.rank] !== rankOrder[b.rank]) {
                return rankOrder[b.rank] - rankOrder[a.rank];
            }
            return suitOrder[b.suit] - suitOrder[a.suit];
        }

        // 更新界面
        function updateUI() {
            try {
                // 玩家手牌
                const playerHand = document.getElementById('player-hand');
                playerHand.innerHTML = '';
                if (hands[0] && Array.isArray(hands[0])) {
                    hands[0].forEach((card, index) => {
                        const cardDiv = document.createElement('div');
                        cardDiv.classList.add('card');
                        cardDiv.classList.add(['♥', '♦'].includes(card.suit) ? 'red' : 'black');
                        if (selectedCards.includes(index)) {
                            cardDiv.classList.add('selected');
                        }
                        cardDiv.textContent = `${card.suit}${card.rank}`;
                        cardDiv.onclick = () => toggleCardSelection(index);
                        playerHand.appendChild(cardDiv);
                    });
                }

                // AI手牌
                for (let i = 1; i <= 3; i++) {
                    const aiHand = document.getElementById(`ai${i}-hand`);
                    aiHand.innerHTML = '';
                    if (hands[i] && Array.isArray(hands[i])) {
                        for (let j = 0; j < hands[i].length; j++) {
                            const cardDiv = document.createElement('div');
                            cardDiv.classList.add('opponent-card');
                            aiHand.appendChild(cardDiv);
                        }
                    }
                }

                // 桌面卡牌
                const tableDiv = document.getElementById('table-cards');
                tableDiv.innerHTML = '';
                if (tableCards && Array.isArray(tableCards)) {
                    tableCards.forEach(card => {
                        const cardDiv = document.createElement('div');
                        cardDiv.classList.add('card');
                        cardDiv.classList.add(['♥', '♦'].includes(card.suit) ? 'red' : 'black');
                        cardDiv.textContent = `${card.suit}${card.rank}`;
                        tableDiv.appendChild(cardDiv);
                    });
                }

                // 分數
                document.getElementById('scores').textContent = `得分: 玩家: ${scores[0]} | AI 1: ${scores[1]} | AI 2: ${scores[2]} | AI 3: ${scores[3]}`;
            } catch (e) {
                console.error('Update UI error:', e);
            }
        }

        // 更新狀態
        function updateStatus() {
            const names = ['玩家', 'AI 1', 'AI 2', 'AI 3'];
            if (hands.some(hand => hand && hand.length === 0)) {
                calculateScores();
                document.getElementById('status').textContent = `回合結束！${names[hands.findIndex(hand => hand && hand.length === 0)]} 獲勝！`;
            } else {
                document.getElementById('status').textContent = `輪到 ${names[currentPlayer]}`;
            }
        }

        // 選擇卡牌
        function toggleCardSelection(index) {
            if (currentPlayer !== 0) return;
            const idx = selectedCards.indexOf(index);
            if (idx === -1) {
                selectedCards.push(index);
            } else {
                selectedCards.splice(idx, 1);
            }
            updateUI();
        }

        // 出牌
        function playCards() {
            if (currentPlayer !== 0) return;
            const cards = selectedCards.map(i => hands[0][i]);
            if (cards.length === 0) {
                alert('請選擇卡牌！');
                return;
            }
            const combo = getCombination(cards);
            if (!combo) {
                alert('無效組合！');
                selectedCards = [];
                updateUI();
                return;
            }
            if (lastPlayed && !canBeat(combo, lastPlayed)) {
                alert('出牌必須大於桌面上的牌！');
                selectedCards = [];
                updateUI();
                return;
            }
            if (lastPlayed && combo.type !== lastPlayed.type) {
                alert('組合類型必須相同！');
                selectedCards = [];
                updateUI();
                return;
            }
            if (!lastPlayed && cards.length > 0 && !cards.some(card => card.rank === '3' && card.suit === '♣')) {
                alert('第一輪必須包含♣3！');
                selectedCards = [];
                updateUI();
                return;
            }
            playSound.play().catch(e => console.log('Play sound error:', e));
            animateCards(cards, 'player');
            selectedCards.sort((a, b) => b - a);
            for (let i of selectedCards) {
                hands[0].splice(i, 1);
            }
            selectedCards = [];
            passes = 0;
            nextPlayer();
        }

        // 過牌
        function pass() {
            if (currentPlayer !== 0) return;
            passSound.play().catch(e => console.log('Pass sound error:', e));
            passes++;
            if (passes >= 3) {
                tableCards = [];
                lastPlayed = null;
                passes = 0;
            }
            nextPlayer();
        }

        // 下一個玩家
        function nextPlayer() {
            currentPlayer = (currentPlayer + 1) % 4;
            updateUI();
            updateStatus();
            if (hands[currentPlayer] && hands[currentPlayer].length === 0) {
                calculateScores();
                return;
            }
            if (currentPlayer !== 0) {
                setTimeout(aiPlay, 1000);
            }
        }

        // AI出牌
        function aiPlay() {
            const hand = hands[currentPlayer];
            if (!hand) return;
            if (!lastPlayed) {
                let cards = hand.filter(card => card.rank === '3' && card.suit === '♣');
                if (cards.length > 0) {
                    playSound.play().catch(e => console.log('Play sound error:', e));
                    animateCards(cards, `ai${currentPlayer}`);
                    tableCards = cards;
                    lastPlayed = getCombination(cards);
                    hands[currentPlayer] = hand.filter(card => !cards.includes(card));
                    passes = 0;
                    nextPlayer();
                    return;
                }
            }
            const combos = getAllCombinations(hand);
            let validCombo = null;
            for (let combo of combos) {
                if (!lastPlayed || (combo.type === lastPlayed.type && canBeat(combo, lastPlayed))) {
                    validCombo = combo;
                    break;
                }
            }
            if (validCombo) {
                playSound.play().catch(e => console.log('Play sound error:', e));
                animateCards(validCombo.cards, `ai${currentPlayer}`);
                tableCards = validCombo.cards;
                lastPlayed = validCombo;
                hands[currentPlayer] = hand.filter(card => !validCombo.cards.includes(card));
                passes = 0;
            } else {
                passSound.play().catch(e => console.log('Pass sound error:', e));
                passes++;
                if (passes >= 3) {
                    tableCards = [];
                    lastPlayed = null;
                    passes = 0;
                }
            }
            nextPlayer();
        }

        // 卡牌滑動動畫
        function animateCards(cards, source) {
            const tableDiv = document.getElementById('table-cards');
            tableDiv.innerHTML = '';
            cards.forEach(card => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card', ['♥', '♦'].includes(card.suit) ? 'red' : 'black', 'animate');
                cardDiv.textContent = `${card.suit}${card.rank}`;
                // 根據來源設置初始位置
                let startX = 0, startY = 0;
                if (source === 'player') {
                    startX = 0;
                    startY = 200; // 從下方（玩家手牌）
                } else if (source === 'ai1') {
                    startX = 0;
                    startY = -200; // 從上方（AI1）
                } else if (source === 'ai2') {
                    startX = 300; // 從右側（AI2）
                    startY = 0;
                } else if (source === 'ai3') {
                    startX = -300; // 從左側（AI3）
                    startY = 0;
                }
                cardDiv.style.transform = `translate(${startX}px, ${startY}px)`;
                tableDiv.appendChild(cardDiv);
                // 觸發滑動到中心
                setTimeout(() => {
                    cardDiv.style.transform = 'translate(0, 0)';
                    cardDiv.classList.remove('animate');
                }, 50);
            });
            // 更新tableCards
            setTimeout(() => {
                tableCards = cards;
                updateUI();
            }, 500);
        }

        // 獲取卡牌組合
        function getCombination(cards) {
            cards.sort(compareCards);
            if (cards.length === 1) {
                return { type: 'single', value: rankOrder[cards[0].rank], suit: suitOrder[cards[0].suit], cards };
            }
            if (cards.length === 2 && cards[0].rank === cards[1].rank) {
                return { type: 'pair', value: rankOrder[cards[0].rank], suit: Math.max(suitOrder[cards[0].suit], suitOrder[cards[1].suit]), cards };
            }
            if (cards.length === 3 && cards[0].rank === cards[1].rank && cards[1].rank === cards[2].rank) {
                return { type: 'triple', value: rankOrder[cards[0].rank], cards };
            }
            if (cards.length === 5) {
                if (isStraightFlush(cards)) return { type: 'straightFlush', value: rankOrder[cards[0].rank], cards };
                if (isFourOfAKind(cards)) return { type: 'fourOfAKind', value: rankOrder[cards[1].rank], cards };
                if (isFullHouse(cards)) return { type: 'fullHouse', value: rankOrder[cards[2].rank], cards };
                if (isFlush(cards)) return { type: 'flush', value: rankOrder[cards[0].rank], suit: suitOrder[cards[0].suit], cards };
                if (isStraight(cards)) return { type: 'straight', value: rankOrder[cards[0].rank], cards };
            }
            return null;
        }

        // 檢查是否能打敗
        function canBeat(newCombo, oldCombo) {
            if (newCombo.type !== oldCombo.type) return false;
            if (['single', 'pair', 'flush'].includes(newCombo.type)) {
                if (newCombo.value !== oldCombo.value) {
                    return newCombo.value > oldCombo.value;
                }
                return newCombo.suit > oldCombo.suit;
            }
            if (['straightFlush', 'fourOfAKind', 'fullHouse', 'straight', 'triple'].includes(newCombo.type)) {
                return newCombo.value > oldCombo.value;
            }
            return false;
        }

        // 獲取所有可能組合
        function getAllCombinations(hand) {
            let combos = [];
            hand.forEach(card => combos.push({ type: 'single', value: rankOrder[card.rank], suit: suitOrder[card.suit], cards: [card] }));
            for (let i = 0; i < hand.length - 1; i++) {
                if (hand[i].rank === hand[i + 1].rank) {
                    combos.push({ type: 'pair', value: rankOrder[hand[i].rank], suit: Math.max(suitOrder[hand[i].suit], suitOrder[hand[i + 1].suit]), cards: [hand[i], hand[i + 1]] });
                }
            }
            for (let i = 0; i < hand.length - 2; i++) {
                if (hand[i].rank === hand[i + 1].rank && hand[i + 1].rank === hand[i + 2].rank) {
                    combos.push({ type: 'triple', value: rankOrder[hand[i].rank], cards: [hand[i], hand[i + 1], hand[i + 2]] });
                }
            }
            if (hand.length >= 5) {
                let fiveCards = hand.slice(0, 5);
                let combo = getCombination(fiveCards);
                if (combo) combos.push(combo);
            }
            return combos.sort((a, b) => {
                if (a.value !== b.value) return a.value - b.value;
                if (a.suit && b.suit) return a.suit - b.suit;
                return 0;
            });
        }

        // 五張牌組合檢查
        function isStraight(cards) {
            let values = cards.map(card => rankOrder[card.rank]).sort((a, b) => b - a);
            for (let i = 1; i < values.length; i++) {
                if (values[i - 1] - values[i] !== 1) return false;
            }
            return true;
        }

        function isFlush(cards) {
            return cards.every(card => card.suit === cards[0].suit);
        }

        function isFullHouse(cards) {
            let ranks = cards.map(card => card.rank);
            let counts = {};
            ranks.forEach(rank => counts[rank] = (counts[rank] || 0) + 1);
            return Object.values(counts).sort().join('') === '23';
        }

        function isFourOfAKind(cards) {
            let ranks = cards.map(card => card.rank);
            let counts = {};
            ranks.forEach(rank => counts[rank] = (counts[rank] || 0) + 1);
            return Object.values(counts).includes(4);
        }

        function isStraightFlush(cards) {
            return isStraight(cards) && isFlush(cards);
        }

        // 計算得分
        function calculateScores() {
            let winner = hands.findIndex(hand => hand && hand.length === 0);
            if (winner === -1) return;
            let points = 0;
            hands.forEach((hand, index) => {
                if (index !== winner && hand) {
                    let count = hand.length;
                    let penalty = count <= 9 ? count : count <= 12 ? count * 2 : count * 3;
                    points += penalty;
                }
            });
            scores[winner] += points;
            updateUI();
            updateStatus();
        }

        // 重置遊戲
        function resetGame() {
            scores = [0, 0, 0, 0];
            initGame();
        }

        // 初始化遊戲
        initGame();
    </script>
</body>
</html>
