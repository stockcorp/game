<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 西洋棋遊戲 - 增強版</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #game-container {
            display: flex;
            gap: 20px;
        }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            cursor: pointer;
        }
        .white {
            background-color: #fff;
        }
        .black {
            background-color: #769656;
        }
        .selected {
            background-color: #ffff99 !important;
        }
        .highlight {
            background-color: #aaffaa !important;
        }
        #sidebar {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #status {
            font-size: 18px;
            color: #333;
        }
        #move-history {
            width: 200px;
            height: 300px;
            overflow-y: auto;
            background-color: #fff;
            border: 1px solid #333;
            padding: 10px;
            font-size: 14px;
        }
        #timer {
            font-size: 16px;
            color: #333;
        }
        button {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="chessboard"></div>
        <div id="sidebar">
            <div id="status">輪到白方</div>
            <div id="timer">白方: 10:00 | 黑方: 10:00</div>
            <div id="move-history"></div>
            <button onclick="resetGame()">重置遊戲</button>
            <button onclick="undoMove()">悔棋</button>
        </div>
    </div>

    <script>
        // 棋盤初始狀態
        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // 棋子對應的Unicode符號
        const pieceSymbols = {
            'P': '♙', 'p': '♟',
            'R': '♖', 'r': '♜',
            'N': '♘', 'n': '♞',
            'B': '♗', 'b': '♝',
            'Q': '♕', 'q': '♛',
            'K': '♔', 'k': '♚'
        };

        // 遊戲狀態
        let board = JSON.parse(JSON.stringify(initialBoard));
        let selectedSquare = null;
        let currentPlayer = 'white';
        let moveHistory = [];
        let boardHistory = [JSON.parse(JSON.stringify(initialBoard))];
        let castling = { whiteKing: true, whiteRookA: true, whiteRookH: true, blackKing: true, blackRookA: true, blackRookH: true };
        let timers = { white: 600, black: 600 };
        let timerInterval = null;

        // 初始化棋盤
        const chessboard = document.getElementById('chessboard');
        function createBoard() {
            chessboard.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.classList.add('square', (row + col) % 2 === 0 ? 'white' : 'black');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.textContent = pieceSymbols[board[row][col]] || '';
                    square.addEventListener('click', handleSquareClick);
                    chessboard.appendChild(square);
                }
            }
        }

        // 處理格子點擊
        function handleSquareClick(event) {
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            const piece = board[row][col];

            if (selectedSquare) {
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    movePiece(selectedSquare.row, selectedSquare.col, row, col);
                    clearHighlights();
                    selectedSquare = null;
                    if (isCheckmate(currentPlayer === 'white' ? 'black' : 'white')) {
                        endGame(`${currentPlayer}方勝！對方被將死。`);
                        return;
                    }
                    if (isCheck(currentPlayer === 'white' ? 'black' : 'white')) {
                        document.getElementById('status').textContent = `輪到${currentPlayer === 'white' ? '黑方' : '白方'}（將軍！）`;
                    }
                    switchPlayer();
                    if (currentPlayer === 'black') {
                        setTimeout(aiMove, 500);
                    }
                } else {
                    clearHighlights();
                    selectedSquare = null;
                    if (piece && isPlayerPiece(piece)) {
                        selectSquare(row, col);
                    }
                }
            } else if (piece && isPlayerPiece(piece)) {
                selectSquare(row, col);
            }
        }

        // 選擇格子並高亮
        function selectSquare(row, col) {
            selectedSquare = { row, col };
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => square.classList.remove('selected', 'highlight'));
            const selected = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            selected.classList.add('selected');
            highlightValidMoves(row, col);
        }

        // 高亮可移動格子
        function highlightValidMoves(row, col) {
            const moves = getValidMoves(row, col);
            moves.forEach(([r, c]) => {
                const square = document.querySelector(`.square[data-row="${r}"][data-col="${c}"]`);
                if (square) square.classList.add('highlight');
            });
        }

        // 獲取合法移動
        function getValidMoves(row, col) {
            const piece = board[row][col].toLowerCase();
            const isWhite = board[row][col] === board[row][col].toUpperCase();
            let moves = [];

            if (piece === 'p') {
                const direction = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                if (isEmpty(row + direction, col)) {
                    moves.push([row + direction, col]);
                    if (row === startRow && isEmpty(row + 2 * direction, col)) {
                        moves.push([row + 2 * direction, col]);
                    }
                }
                if (isEnemy(row + direction, col - 1)) moves.push([row + direction, col - 1]);
                if (isEnemy(row + direction, col + 1)) moves.push([row + direction, col + 1]);
            } else if (piece === 'r') {
                moves = moves.concat(getRookMoves(row, col));
            } else if (piece === 'n') {
                const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                knightMoves.forEach(([dr, dc]) => {
                    const r = row + dr, c = col + dc;
                    if (isValidSquare(r, c) && (isEmpty(r, c) || isEnemy(r, c))) moves.push([r, c]);
                });
            } else if (piece === 'b') {
                moves = moves.concat(getBishopMoves(row, col));
            } else if (piece === 'q') {
                moves = moves.concat(getRookMoves(row, col), getBishopMoves(row, col));
            } else if (piece === 'k') {
                const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                kingMoves.forEach(([dr, dc]) => {
                    const r = row + dr, c = col + dc;
                    if (isValidSquare(r, c) && (isEmpty(r, c) || isEnemy(r, c))) moves.push([r, c]);
                });
                // 王車易位
                if ((isWhite && castling.whiteKing) || (!isWhite && castling.blackKing)) {
                    if (castling[isWhite ? 'whiteRookH' : 'blackRookH'] && board[row][5] === '' && board[row][6] === '' && !isSquareAttacked(row, 5, isWhite) && !isSquareAttacked(row, 6, isWhite)) {
                        moves.push([row, 6]);
                    }
                    if (castling[isWhite ? 'whiteRookA' : 'blackRookA'] && board[row][1] === '' && board[row][2] === '' && board[row][3] === '' && !isSquareAttacked(row, 2, isWhite) && !isSquareAttacked(row, 3, isWhite)) {
                        moves.push([row, 2]);
                    }
                }
            }

            // 過濾導致己方將軍的移動
            return moves.filter(([r, c]) => {
                const tempBoard = JSON.parse(JSON.stringify(board));
                tempBoard[r][c] = tempBoard[row][col];
                tempBoard[row][col] = '';
                return !isCheck(isWhite ? 'white' : 'black', tempBoard);
            });
        }

        // 車的移動
        function getRookMoves(row, col) {
            const moves = [];
            for (let r = row + 1; r < 8 && isEmptyOrEnemy(r, col); r++) {
                moves.push([r, col]);
                if (!isEmpty(r, col)) break;
            }
            for (let r = row - 1; r >= 0 && isEmptyOrEnemy(r, col); r--) {
                moves.push([r, col]);
                if (!isEmpty(r, col)) break;
            }
            for (let c = col + 1; c < 8 && isEmptyOrEnemy(row, c); c++) {
                moves.push([row, c]);
                if (!isEmpty(row, c)) break;
            }
            for (let c = col - 1; c >= 0 && isEmptyOrEnemy(row, c); c--) {
                moves.push([row, c]);
                if (!isEmpty(row, c)) break;
            }
            return moves;
        }

        // 象的移動
        function getBishopMoves(row, col) {
            const moves = [];
            for (let i = 1; isEmptyOrEnemy(row + i, col + i); i++) {
                moves.push([row + i, col + i]);
                if (!isEmpty(row + i, col + i)) break;
            }
            for (let i = 1; isEmptyOrEnemy(row + i, col - i); i++) {
                moves.push([row + i, col - i]);
                if (!isEmpty(row + i, col - i)) break;
            }
            for (let i = 1; isEmptyOrEnemy(row - i, col + i); i++) {
                moves.push([row - i, col + i]);
                if (!isEmpty(row - i, col + i)) break;
            }
            for (let i = 1; isEmptyOrEnemy(row - i, col - i); i++) {
                moves.push([row - i, col - i]);
                if (!isEmpty(row - i, col - i)) break;
            }
            return moves;
        }

        // 檢查是否為當前玩家的棋子
        function isPlayerPiece(piece) {
            return (currentPlayer === 'white' && piece === piece.toUpperCase()) ||
                   (currentPlayer === 'black' && piece === piece.toLowerCase());
        }

        // 檢查格子是否為空或敵方
        function isEmptyOrEnemy(row, col) {
            if (!isValidSquare(row, col)) return false;
            const piece = board[row][col];
            if (!piece) return true;
            return (currentPlayer === 'white' && piece === piece.toLowerCase()) ||
                   (currentPlayer === 'black' && piece === piece.toUpperCase());
        }

        // 檢查是否為敵方
        function isEnemy(row, col) {
            if (!isValidSquare(row, col)) return false;
            const piece = board[row][col];
            if (!piece) return false;
            return (currentPlayer === 'white' && piece === piece.toLowerCase()) ||
                   (currentPlayer === 'black' && piece === piece.toUpperCase());
        }

        // 檢查是否為空
        function isEmpty(row, col) {
            if (!isValidSquare(row, col)) return false;
            return !board[row][col];
        }

        // 檢查有效格子
        function isValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // 驗證移動
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const moves = getValidMoves(fromRow, fromCol);
            return moves.some(([r, c]) => r === toRow && c === toCol);
        }

        // 移動棋子
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const moveNotation = `${piece}${String.fromCharCode(97 + fromCol)}${8 - fromRow} -> ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';

            // 處理王車易位
            if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                if (toCol === 6) {
                    board[toRow][5] = board[toRow][7];
                    board[toRow][7] = '';
                } else if (toCol === 2) {
                    board[toRow][3] = board[toRow][0];
                    board[toRow][0] = '';
                }
            }

            // 更新王車易位狀態
            if (piece.toLowerCase() === 'k') {
                if (piece === 'K') castling.whiteKing = false;
                else castling.blackKing = false;
            }
            if (piece.toLowerCase() === 'r') {
                if (fromRow === 7 && fromCol === 0) castling.whiteRookA = false;
                if (fromRow === 7 && fromCol === 7) castling.whiteRookH = false;
                if (fromRow === 0 && fromCol === 0) castling.blackRookA = false;
                if (fromRow === 0 && fromCol === 7) castling.blackRookH = false;
            }

            // 保存棋盤狀態
            moveHistory.push(moveNotation);
            boardHistory.push(JSON.parse(JSON.stringify(board)));
            updateMoveHistory();
            createBoard();
        }

        // AI移動（簡單隨機選擇）
        function aiMove() {
            const pieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && isPlayerPiece(board[row][col])) {
                        const moves = getValidMoves(row, col);
                        if (moves.length > 0) {
                            pieces.push({ row, col, moves });
                        }
                    }
                }
            }
            if (pieces.length === 0) {
                endGame('白方勝！黑方無合法移動。');
                return;
            }
            const piece = pieces[Math.floor(Math.random() * pieces.length)];
            const move = piece.moves[Math.floor(Math.random() * piece.moves.length)];
            movePiece(piece.row, piece.col, move[0], move[1]);
            if (isCheckmate('white')) {
                endGame('黑方勝！白方被將死。');
                return;
            }
            if (isCheck('white')) {
                document.getElementById('status').textContent = '輪到白方（將軍！）';
            }
            switchPlayer();
        }

        // 檢查將軍
        function isCheck(player, tempBoard = board) {
            const king = player === 'white' ? 'K' : 'k';
            let kingPos = null;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (tempBoard[row][col] === king) {
                        kingPos = [row, col];
                        break;
                    }
                }
                if (kingPos) break;
            }
            if (!kingPos) return false;

            const opponent = player === 'white' ? 'black' : 'white';
            const originalPlayer = currentPlayer;
            currentPlayer = opponent;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (tempBoard[row][col] && isPlayerPiece(tempBoard[row][col])) {
                        const moves = getValidMoves(row, col);
                        if (moves.some(([r, c]) => r === kingPos[0] && c === kingPos[1])) {
                            currentPlayer = originalPlayer;
                            return true;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }

        // 檢查將死
        function isCheckmate(player) {
            if (!isCheck(player)) return false;
            const originalPlayer = currentPlayer;
            currentPlayer = player;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && isPlayerPiece(board[row][col])) {
                        const moves = getValidMoves(row, col);
                        if (moves.length > 0) {
                            currentPlayer = originalPlayer;
                            return false;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return true;
        }

        // 檢查格子是否被攻擊
        function isSquareAttacked(row, col, isWhite) {
            const opponent = isWhite ? 'black' : 'white';
            const originalPlayer = currentPlayer;
            currentPlayer = opponent;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && isPlayerPiece(board[r][c])) {
                        const moves = getValidMoves(r, c);
                        if (moves.some(([mr, mc]) => mr === row && mc === col)) {
                            currentPlayer = originalPlayer;
                            return true;
                        }
                    }
                }
            }
            currentPlayer = originalPlayer;
            return false;
        }

        // 切換玩家
        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            document.getElementById('status').textContent = `輪到${currentPlayer === 'white' ? '白方' : '黑方'}`;
        }

        // 更新移動歷史
        function updateMoveHistory() {
            const historyDiv = document.getElementById('move-history');
            historyDiv.innerHTML = moveHistory.map((move, i) => `${i + 1}. ${move}`).join('<br>');
            historyDiv.scrollTop = historyDiv.scrollHeight;
        }

        // 計時器
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timers[currentPlayer]--;
                if (timers[currentPlayer] <= 0) {
                    endGame(`${currentPlayer === 'white' ? '黑方' : '白方'}勝！${currentPlayer}方時間用盡。`);
                }
                updateTimer();
            }, 1000);
        }

        function updateTimer() {
            const whiteTime = formatTime(timers.white);
            const blackTime = formatTime(timers.black);
            document.getElementById('timer').textContent = `白方: ${whiteTime} | 黑方: ${blackTime}`;
        }

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${min}:${sec < 10 ? '0' : ''}${sec}`;
        }

        // 結束遊戲
        function endGame(message) {
            clearInterval(timerInterval);
            document.getElementById('status').textContent = message;
            chessboard.removeEventListener('click', handleSquareClick);
        }

        // 重置遊戲
        function resetGame() {
            board = JSON.parse(JSON.stringify(initialBoard));
            currentPlayer = 'white';
            selectedSquare = null;
            moveHistory = [];
            boardHistory = [JSON.parse(JSON.stringify(initialBoard))];
            castling = { whiteKing: true, whiteRookA: true, whiteRookH: true, blackKing: true, blackRookA: true, blackRookH: true };
            timers = { white: 600, black: 600 };
            clearInterval(timerInterval);
            createBoard();
            updateMoveHistory();
            updateTimer();
            document.getElementById('status').textContent = '輪到白方';
            startTimer();
        }

        // 悔棋
        function undoMove() {
            if (boardHistory.length <= 1) return;
            boardHistory.pop();
            board = JSON.parse(JSON.stringify(boardHistory[boardHistory.length - 1]));
            moveHistory.pop();
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            selectedSquare = null;
            createBoard();
            updateMoveHistory();
            document.getElementById('status').textContent = `輪到${currentPlayer === 'white' ? '白方' : '黑方'}`;
        }

        // 清除高亮
        function clearHighlights() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => square.classList.remove('selected', 'highlight'));
        }

        // 初始化遊戲
        createBoard();
        startTimer();
    </script>
</body>
</html>